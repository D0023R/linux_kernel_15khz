diff -Naur linux-5.0_stock/drivers/gpu/drm/drm_vblank.c linux-5.0/drivers/gpu/drm/drm_vblank.c
--- linux-5.0_stock/drivers/gpu/drm/drm_vblank.c	2019-03-03 23:21:29.000000000 +0000
+++ linux-5.0/drivers/gpu/drm/drm_vblank.c	2019-03-04 09:35:58.690014048 +0000
@@ -1532,6 +1531,10 @@
 	unsigned int pipe_index;
 	unsigned int flags, pipe, high_pipe;
 
+	int vpos, hpos;
+	const struct drm_display_mode *mode;
+	bool vbl_status;
+
 	if (!dev->irq_enabled)
 		return -EINVAL;
 
@@ -1540,7 +1543,7 @@
 
 	if (vblwait->request.type &
 	    ~(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |
-	      _DRM_VBLANK_HIGH_CRTC_MASK)) {
+	      _DRM_VBLANK_HIGH_CRTC_MASK | 0x40 )) { // use 0x40 constant for DRM_VBLANK_SCANOUT_POSITION support
 		DRM_DEBUG("Unsupported type value 0x%x, supported mask 0x%x\n",
 			  vblwait->request.type,
 			  (_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |
@@ -1575,6 +1578,49 @@
 
 	vblank = &dev->vblank[pipe];
 
+	if ( vblwait->request.type & 0x40 ) {
+
+		 crtc = drm_crtc_from_index(dev, pipe);
+	         if (drm_drv_uses_atomic_modeset(dev))
+		 	mode = &vblank->hwmode;
+	         else
+		        mode = &crtc->hwmode;
+
+		 /*
+		  * Returns vpos as a positive number while in active scanout area.
+		  * Returns vpos as a negative number inside vblank, counting the number
+		  * of scanlines to go until end of vblank, e.g., -1 means "one scanline
+		  * until start of active scanout / end of vblank."
+		  */
+
+		vbl_status = dev->driver->get_scanout_position(dev, pipe,
+				0, // in_vblank_irq,
+				&vpos, &hpos,
+				NULL, NULL, // &stime, &etime,
+				mode);
+
+		if (!vbl_status) {
+		                DRM_DEBUG("crtc %u : scanoutpos query failed.\n",
+		                           pipe);
+		      return -EINVAL;
+		}
+
+		// - Returns sequence as a positive number while in active scanout area.
+		// - Returns sequence as a negative number inside vblank.
+		// Note: 0 is the first active scanline on the screen, vblank scanlines are always at the end
+
+		if ( vpos < 0 ) { // use real scanout position, starting from first visible scanline   
+                      vpos += mode->crtc_vtotal;
+		}
+
+		if ( vpos > mode->crtc_vblank_start ) { // turn position in negative values during vblank
+		      vpos = -vpos;
+		}
+
+		vblwait->reply.sequence = vpos;
+		return 0;
+	} 
+
 	/* If the counter is currently enabled and accurate, short-circuit
 	 * queries to return the cached timestamp of the last vblank.
 	 */
